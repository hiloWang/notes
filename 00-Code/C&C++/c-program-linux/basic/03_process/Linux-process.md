# Linux 进程

每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux 内核的进程控制块是 task_struct 结构体。task_struct 中包含以下信息：

- 进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。
- 进程的状态，有运行、挂起、停止、僵尸等状态。
- 进程切换时需要保存和恢复的一些 CPU 寄存器。
- 描述虚拟地址空间的信息。
- 描述控制终端的信息。
- 当前工作目录（Current Working Directory）。
- umask掩码。
- 文件描述符表，包含很多指向file结构体的指针。
- 和信号相关的信息。
- 用户 id 和组 id。
- 控制终端、Session 和进程组。
- 进程可以使用的资源上限（Resource Limit）。

两个重要的系统调用：`fork` 和 `exec`

- fork 的作用是根据一个现有的进程复制出一个新进程，原来的进程称为父进程（Parent Process），新进程称为子进程（Child Process）。系统中同时运行着很多进程，这些进程都是从最初只有一个进程开始一个一个复制出来的。在 Shell 下输入命令可以运行一个程序，是因为 Shell 进程在读取用户输入的命令之后会调用 fork 复制出一个新的 Shell 进程，然后新的 Shell 进程调用 exec 执行新的程序。
- exec 函数族的作用是执行参数所指定的可执行文件或脚本。这个函数会替换掉当前进程的内存镜像，也就是执行这个函数成功后，调用该函数的程序就不存在了。
- 一个程序可以多次加载到内存，成为同时运行的多个进程，例如可以同时开多个终端窗口运行 /bin/bash，另一方面，一个进程在调用exec前后也可以分别执行两个不同的程序，例如在 Shell 提示符下输入命令 ls，首先 fork 创建子进程，这时子进程仍在执行 /bin/bash 程序，然后子进程调用 exec 执行新的程序 /bin/ls。

具体参考[LinuxC一站式编程：第 28 章 第 30 章 进程](https://akaedu.github.io/book/ch30s01.html)

## 环境变量

- libc 中定义的全局变量 environ 指向环境变量表。
- getenv 函数
- setenv 函数
- unsetenv 函数

具体参考[LinuxC一站式编程：第 28 章 第 30 章 环境变量](https://akaedu.github.io/book/ch30s02.html)

## 进程控制

具体参考[LinuxC一站式编程：第 28 章 第 30 章 环境变量](https://akaedu.github.io/book/ch30s03.html)

### fork 函数

### exec 函数族

用 fork 创建子进程后执行的是和父进程相同的程序（但有可能执行不同的代码分支），子进程往往要调用一种 exec 函数以执行另一个程序。当进程调用一种 exec 函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用 exec 并不创建新进程，所以调用 exec 前后该进程的 id 并未改变。

exec 函数如果调用成功则加载新的程序从启动代码开始执行，不再返回，如果调用出错则返回-1，所以exec函数只有出错的返回值而没有成功的返回值。

### `wait、waitpid` 函数

一个进程在终止时会关闭所有文件描述符，释放在用户空间分配的内存，但它的 PCB 还保留着，内核在其中保存了一些信息：如果是正常终止则保存着退出状态，如果是异常终止则保存着导致该进程终止的信号是哪个。这个进程的父进程可以调用 wait 或w aitpid 获取这些信息，然后彻底清除掉这个进程。

## 进程间通信

每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。

具体参考[LinuxC一站式编程：第 28 章 第 30 章 进程间通信](https://akaedu.github.io/book/ch30s04.html)

### 管道

管道是一种最基本的 IPC 机制，由 pipe 函数创建，调用 pipe 函数时在内核中开辟一块缓冲区（称为管道）用于通信，它有一个读端一个写端，然后通过 filedes 参数传出给用户程序两个文件描述符，`filedes[0]` 指向管道的读端，`filedes[1]` 指向管道的写端。所以管道在用户程序看起来就像一个打开的文件，通过`read(filedes[0]);`或者`write(filedes[1]);`向这个文件读写数据其实是在读写内核缓冲区。pipe 函数调用成功返回 0，调用失败返回 -1。

管道如何实现通信：

1. 父进程调用 pipe 开辟管道，得到两个文件描述符指向管道的两端。
2. 父进程调用 fork 创建子进程，那么子进程也有两个文件描述符指向同一管道。
3. 父进程关闭管道读端，子进程关闭管道写端。父进程可以往管道里写，子进程可以从管道里读，管道是用环形队列实现的，数据从写端流入从读端流出，这样就实现了进程间通信。

管道的限制：

- 两个进程通过一个管道只能实现单向通信。
- 管道的读写端通过打开的文件描述符来传递，因此要通信的两个进程必须从它们的公共祖先那里继承管道文件描述符。

### 其它 IPC 机制

进程间通信必须通过内核提供的通道，而且必须有一种办法在进程中标识内核提供的某个通道，管道是用打开的文件描述符来标识的。如果要互相通信的几个进程没有从公共祖先那里继承文件描述符，它们怎么通信呢？内核提供一条通道不成问题，问题是如何标识这条通道才能使各进程都可以访问它？文件系统中的路径名是全局的，各进程都可以访问，因此可以用文件系统中的路径名来标识一个 IPC 通道。

### 进程之间传递信息的各种途径

- 父进程通过 fork 可以将打开文件的描述符传递给子进程
- 子进程结束时，父进程调用wait可以得到子进程的终止信息
- 几个进程可以在文件系统中读写某个共享文件，也可以通过给文件加锁来实现进程间同步
- 进程之间互发信号，一般使用 SIGUSR1 和 SIGUSR2 实现用户自定义功能
- 管道
- FIFO
- mmap函数，几个进程可以映射同一内存区
- UNIX Domain Socket，目前最广泛使用的 IPC 机制
