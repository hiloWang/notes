# Java对象创建过程


## 1 Java对象的创建

Java是一门面向对象的语言，程序的执行无时无刻都在进行着对象的创建，那么对象(不包括数组和Class对象)的创建过程时如何的呢？

虚拟机遇到一条new指令时：

**1 加载类：** 首先将要去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，检查这个类是否被加载了，如果没有被加载，则先先去加载这个类。

**2 分配内存：** 虚拟机为新生对象分配内存，对象所需要的内存大小在类被加载完成后既可以完全确定，分配内存的方式有两种：

- 指针碰撞(Bump the pointer)：假设Java堆是完全规整的，所有用过的内存在一边，空闲的内存放在另一边，中间放着一个指针作为分界点，那么分配内存仅仅是把这个指针向空闲的那边挪动与对象大小相等的距离。
- 空闲列表（Free List）：Java堆不是完全规整的，已使用的内存与空闲内存相互交错

使用何种分配方法与堆内存是否规整决定，堆内存是否规整又由采用那种垃圾回收器决定。

对象分配内存需要保证线程安全，比如线程A正在给对象A分配内存，指针还没来得及移动，线程B又要移动指针为对象B分配内存，保证线程安全的方案有两种：

- CAS锁
- TLAB(Thread Local Allocation Buffer)

内存分配完之后，虚拟机将分配到的内存都初始化为零值，这一步操作保证Java代码中的字段不被赋值就可以被使用。

**3 设置：**虚拟机对对象进行必要的设置，例如这个对象属于哪个类的实例，如何才能找到对象的元数据，对象的哈希码，对象的GC分代年龄等信息，最后调用init方法完成对象的显示初始化。

---
## 2 对象的内存布局

对象在内存中存储的布局可以分为3块区域：对象头(Header)、实例数据(Instance Data)、对齐填充(Padding)。

### 对象头

**对象头** 可以分为两部分，第一部分用于存储对象自身运行是数据：哈希姆、GC分代年龄、锁状态标记、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据在32位和64位虚拟机中分别为32Bit和64位Bit，观察称之为Mark Work；第二部分为类型指针，即对象指向它的类元数据指针，虚拟机通过这个指针来确定对象是哪个类的实例，除此之外如果对象是数组类型的，那在对象头中还需要用于记录数据长度的数据。

### 实例数据部分

**实例数据部分** 用于存储对象真正有效信息，也就是在程序代码中定义的各种字段内容。

### 对齐填充

**对齐填充** 不是必然存在的，仅仅起着占位符的作用，而HotSpot VM的自动内存管理系统要求对象的起始位置必须是8Bit的整数倍，也就是对象的大小必须的8Bit的整数倍，而对象头正好是8Bit的倍数(1倍或者2倍)，因此当示例数据部分没有对齐时，就通过对齐填充来补全。

---
## 3 对象的访问定义

Java程序中通过栈中的Reference数据来操作堆上的具体对象，由于Reference类型在Java虚拟机中只规定了一个指向对象的引用，并没有说明如何通过引用定位到堆中对象的具体位置，所以定位对象的方式由虚拟机实现来决定，目前主流的方式有两种：**使用句柄或者直接指针**。Sun HotSpot VM采用的是直接指针。










