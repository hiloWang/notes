# 4 强引用、软引用、弱引用、幻象引用有什么区别？

在 Java 语言中，除了原始数据类型的变量，其他所有都是所谓的引用类型，指向各种不同的对象，理解引用对于掌握 Java 对象生命周期和 JVM 内部相关机制非常有帮助。那么**强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？**

---
## 1 典型回答

**强引用**：

- 所谓强引用（"Strong" Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。即使将要发生 OOM。

**软引用**：

- 软引用（SoftReference），是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。
- JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。
- 软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。

**弱引用**：

- 弱引用（WeakReference）是比软引用更弱化的一种引用，它并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。只要垃圾回收器发现了弱引用就有能回收它

**幻象引用**：

- 幻象引用（PhantomReference）有时候也翻译成虚引用，你不能通过它访问对象。
- 幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem(死后的；事后的) 清理机制。
- 也有人利用幻象引用监控对象的创建和销毁。

---
## 2 考点分析

这道面试题，属于既偏门又非常高频的一道题目。说它偏门，是因为在大多数应用开发中，很少直接操作各种不同引用，虽然我们使用的类库、框架可能利用了其机制。它被频繁问到，是因为这是一个综合性的题目，既考察了我们对基础概念的理解，也考察了对底层对象生命周期、垃圾收集机制等的掌握。

充分理解这些引用，对于我们设计可靠的缓存等框架，或者诊断应用 OOM 等问题，会很有帮助。比如，诊断 MySQL connector-j 驱动在特定模式下（useCompression=true）的内存泄漏问题，就需要我们理解怎么排查幻象引用的堆积问题。


---
## 3 对象可达性状态流转分析

下图简单总结了对象生命周期和不同可达性状态，以及不同状态可能的改变关系：

![](index_files/rea.png)

这是 Java 定义的不同可达性级别（reachability level），具体如下：

- 强可达（Strongly Reachable），就是当一个对象可以有一个或多个线程可以不通过各种引用访问到的情况。比如，我们新创建一个对象，那么创建它的线程对它就是强可达。
- 软可达（Softly Reachable），就是当我们只能通过软引用才能访问到对象的状态。
- 弱可达（Weakly Reachable），就是无法通过强引用或者软引用访问，只能通过弱引用访问时的状态。**这是十分临近 finalize 状态的时机，当弱引用被清除的时候，就符合 finalize 的条件了。**
- 幻象可达（Phantom Reachable），就是没有强、软、弱引用关联，并且 finalize 过了，只有幻象引用指向这个对象的时候。

**判断对象可达性，是 JVM 垃圾收集器决定如何处理对象的一部分考虑。**

### 处理好软引用、弱引用对象

- 除了幻象引用（因为 get 永远返回 null），如果对象还没有被销毁，都可以通过 get 方法获取原有对象。这意味着，利用软引用和弱引用，我们可以将访问到的对象，重新指向强引用
- 因为软引用、弱引用的对象可以重新指向强引用，对于软引用、弱引用之类，垃圾收集器可能会存在**二次确认**的问题，以保证处于弱引用状态的对象，没有改变为强引用。
- 在编程时间中，在处理软引用、弱引用的对象时，要防止错误的重新保持了该类对象强引用（比如，赋值给了 static 变量），那么对象可能就没有机会变回类似弱引用的可达性状态了，就会产生内存泄漏。
- 检查弱引用指向对象是否被垃圾收集，也是诊断是否有特定内存泄漏的一个思路，如果我们的框架使用到弱引用又怀疑有内存泄漏，就可以从这个角度检查。

---
## 4 引用队列（ReferenceQueue）使用

我们在创建各种引用并关联到响应对象时，可以选择是否需要关联引用队列，JVM 会在特定时机将引用 enqueue 到队列里（enque发生在 finalize 之后），我们可以从队列里获取引用（remove 方法在这里实际是有获取的意思）进行相关后续逻辑。**编程实践中，对于幻象引用，get 方法只返回 null，如果不指定引用队列，基本上就没有意义。**

示例代码：利用引用队列，可以在对象处于相应状态时（对于幻象引用，就是前面说的被 finalize 了，处于幻象可达状态），执行后期处理逻辑。

```java
Object counter = new Object();
//引用队列
ReferenceQueue refQueue = new ReferenceQueue<>();
//创建一个关联引用队列的PhantomReference
PhantomReference<Object> p = new PhantomReference<>(counter, refQueue);
counter = null;
//在对象被GC的同时，会把该对象的包装类即 PhantomReference 放入到 ReferenceQueue 里面
System.gc();
try {
    // Remove 是一个阻塞方法，可以指定 timeout，或者选择一直阻塞
    Reference<Object> ref = refQueue.remove(1000L);
    if (ref != null) {
        // do something
    }
} catch (InterruptedException e) {
    // Handle it
}
```

---
## 5 显式地影响软引用垃圾收集

软引用通常会在最后一次引用后，还能保持一段时间，默认值是根据堆剩余空间计算的（以 M bytes 为单位）。从 Java 1.3.1 开始，提供了 -XX:SoftRefLRUPolicyMSPerMB 参数，我们可以以毫秒（milliseconds）为单位设置。比如，下面这个示例就是设置为 3 秒（3000 毫秒）。

```
#这个剩余空间，其实会受不同 JVM 模式影响：
    #对于 Client 模式，比如通常的 Windows 32 bit JDK，剩余空间是计算当前堆里空闲的大小，所以更加倾向于回收
    #对于 server 模式 JVM，则是根据 -Xmx 指定的最大值来计算。
-XX:SoftRefLRUPolicyMSPerMB=3000
```

注意：
- 该参数在新版的 JDK 上也未必有效，
- Client 模式的 JDK 已经逐步退出历史舞台。

---
## 6 诊断 JVM 引用情况

如果你怀疑应用存在引用（或 finalize）导致的回收问题，可以有很多工具或者选项可供选择。比如 HotSpot JVM 自身便提供了明确的选项（PrintReferenceGC）去获取相关信息：

```
# 指定了下面选项去使用 JDK 8 运行一个样例应用
-XX:+PrintGCDetails -XX:+PrintGCTimeStamps -XX:+PrintReferenceGC

# JDK 8 使用 ParrallelGC 收集的垃圾收集日志，各种引用数量非常清晰。
0.403: [GC (Allocation Failure) 0.871: [SoftReference, 0 refs, 0.0000393 secs]0.871: [WeakReference, 8 refs, 0.0000138 secs]0.871: [FinalReference, 4 refs, 0.0000094 secs]0.871: [PhantomReference, 0 refs, 0 refs, 0.0000085 secs]0.871: [JNI Weak Reference, 0.0000071 secs][PSYoungGen: 76272K->10720K(141824K)] 128286K->128422K(316928K), 0.4683919 secs] [Times: user=1.17 sys=0.03, real=0.47 secs]
```

注意：JDK 9 对 JVM 和垃圾收集日志进行了广泛的重构，类似 PrintGCTimeStamps 和 PrintReferenceGC 已经不再存在。


---
## 7 Reachability Fence(栅栏；围栏)

除了前面介绍的几种基本引用类型，也可以通过底层 API 来达到强引用的效果，这就是所谓的设置 **reachability fence**。

为什么需要这种 Reachability Fence 机制？

1. 按照 Java 语言规范，如果一个对象没有指向强引用，就符合垃圾收集的标准，就有可能被回收
2. 有些时候，对象本身并没有强引用，但是也许它的部分属性还在被使用，这样就导致诡异的问题
3. 所以需要一个方法，在没有强引用情况下，通知 JVM 对象是在被使用的。

Java 9 中提供的案例：

```
class Resource {

 private static ExternalResource[] externalResourceArray = ...

 int myIndex;

 Resource(...) {
     myIndex = ...
     externalResourceArray[myIndex] = ...;
     ...
 }

 protected void finalize() {
     externalResourceArray[myIndex] = null;
     ...
 }

 //将需要 reachability 保障的代码段利用 try-finally 包围起来，在 finally 里明确声明对象强可达。
 public void action() {
     try {
         // 需要被保护的代码
         int i = myIndex;
         Resource.update(externalResourceArray[i]);
     } finally {
         // 调用 reachbilityFence，明确保障对象 strongly reachable
         Reference.reachabilityFence(this);
     }
 }

 private static void update(ExternalResource ext) {
    ext.status = ...;
 }

}
```

方法 action 的执行，依赖于对象的部分属性，所以被特定保护了起来。否则，如果我们在代码中像下面这样调用，那么就可能会出现困扰，因为没有强引用指向我们创建出来的 Resource 对象，JVM 对它进行 finalize 操作是完全合法的。

```java
//类似的书写结构，在异步编程中似乎是很普遍的，因为异步编程中往往不会用传统的“执行 -> 返回 -> 使用”的结构。
new Resource().action();
```

### 如何实现  Reachability Fence

- 在 Java 9 之前，实现类似类似功能相对比较繁琐，有的时候需要采取一些比较隐晦的小技巧。
- Java 9 之后 `java.lang.ref.Reference` 给我们提供了新方法，它是 JEP 193: Variable Handles 的一部分，将 Java 平台底层的一些能力暴露出来：`static void reachabilityFence(Object ref)`。

---
## 8 总结与思考题

今天，我总结了 Java 语言提供的几种引用类型、相应可达状态以及对于 JVM 工作的意义，并分析了引用队列使用的一些实际情况，最后介绍了在新的编程模式下，如何利用 API 去保障对象不被以为意外回收，希望对你有所帮助。你能从自己的产品或者第三方类库中找到使用各种引用的案例吗？它们都试图解决什么问题？

###  强引用

特点：我们平常典型编码Object obj = new Object()中的obj就是强引用。通过关键字new创建的对象所关联的引用就是强引用。 当JVM内存空间不足，JVM宁愿抛出OutOfMemoryError运行时错误（OOM），使程序异常终止，也不会靠随意回收具有强引用的“存活”对象来解决内存不足的问题。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，具体回收时机还是要看垃圾收集策略。

###  软引用

特点：软引用通过SoftReference类实现。 软引用的生命周期比强引用短一些。只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象：即JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。后续，我们可以调用ReferenceQueue的poll()方法来检查是否有它所关心的对象被回收。如果队列为空，将返回一个null,否则该方法返回队列中前面的一个Reference对象。

应用场景：软引用通常用来实现内存敏感的缓存。如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。

### 弱引用

弱引用通过WeakReference类实现。 弱引用的生命周期比软引用短。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。由于垃圾回收器是一个优先级很低的线程，因此不一定会很快回收弱引用的对象。弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。

应用场景：弱应用同样可用于内存敏感的缓存。

### 虚引用

特点：虚引用也叫幻象引用，通过PhantomReference类来实现。无法通过虚引用访问对象的任何属性或函数。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。虚引用必须和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。

```
// 程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。
// 如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取一些程序行动。
ReferenceQueue queue = new ReferenceQueue ();
PhantomReference pr = new PhantomReference (object, queue);
```

应用场景：可用来跟踪对象被垃圾回收器回收的活动，当一个虚引用关联的对象被垃圾收集器回收之前会收到一条系统通知。

---
## 9 参考资料

- [Java Reference Objects](http://www.kdgregory.com/index.php?page=java.refobj)
- Java 9 之前如何实现 Reachability Fence