# 可见性、原子性和有序性问题：并发编程Bug的源头

为什么并发编程容易出问题呢？它是怎么出问题的？

---
## 1 并发程序幕后的故事——硬件设备速度的巨大差异性

 CPU、内存、I/O 设备是组成计算机的基础硬件，这些年它们不断朝着更快的方向努力。但是，在这个快速发展的过程中，**有一个核心矛盾一直存在，就是这三者的速度差异**。可以将其形象地描述为：

- CPU 和内存的速度差异可以形象地描述为：CPU 是天上一天，内存是地上一年
- 内存和 I/O 设备的速度差异就更大了，内存是天上一天，I/O 设备是地上十年。

**木桶理论**：程序里大部分语句都要访问内存，有些还要访问 I/O，根据木桶理论:`一只水桶能装多少水取决于它最短的那块木板`。程序整体的性能取决于最慢的操作——读写 I/O 设备，也就是说**单方面提高 CPU 性能是无效的**。

为了合理利用 CPU 的高性能，平衡这三者的速度差异，计算机体系机构、操作系统、编译程序都做出了贡献，主要体现为：

1. CPU 增加了缓存，以均衡与内存的速度差异；
2. 操作系统增加了进程、线程，以分时复用 CPU，进而均衡 CPU 与 I/O 设备的速度差异；
3. 编译程序优化指令执行次序，使得缓存能够得到更加合理地利用。

但凡事有利有弊，并发程序很多诡异问题的根源也在这里。

>CPU 缓存：CPU缓存不存在于内存中的，它是一块比内存更小、读写速度更快的芯片。

---
## 2 源头之一：缓存导致的可见性问题

一个线程对共享变量的修改，另外一个线程能够立刻看到，我们称为可见性。

### 单核时代

所有的线程都是在一颗 CPU 上执行，CPU 缓存与内存的数据一致性容易解决。因为所有线程都是操作同一个 CPU 的缓存，一个线程对缓存的写，对另外一个线程来说一定是可见的。

![](images/01_single_cpu.png)

### 多核时代

每颗 CPU 都有自己的缓存，这时 CPU 缓存与内存的数据一致性就没那么容易解决了，当多个线程在不同的 CPU 上执行时，这些线程操作的是不同的 CPU 缓存。

比如下图中，线程 A 操作的是 CPU-1 上的缓存，而线程 B 操作的是 CPU-2 上的缓存，很明显，这个时候线程 A 对变量 V 的操作对于线程 B 而言就不具备可见性了。

![](images/01_multi_cpu.png)

参考下面代码：

```java
public class VisibilityMain {

    public static void main(String... args) throws InterruptedException {
        //实际上 calc() 的执行结果是个 10000 到 20000 之间的随机数。
        System.out.println("Result = " + Test.calc());
    }

    public static class Test {
        private long count = 0;

        private void add10K() {
            int idx = 0;
            while (idx++ < 10000) {
                count += 1;
            }
        }

        static long calc() throws InterruptedException {
            final Test test = new Test();
            // 创建两个线程，执行 add() 操作
            Thread th1 = new Thread(test::add10K);
            Thread th2 = new Thread(test::add10K);
            // 启动两个线程
            th1.start();
            th2.start();
            // 等待两个线程执行结束
            th1.join();
            th2.join();
            return test.count;
        }
    }

}
```

---
## 3 源头之二：线程切换带来的原子性问题

由于 IO 太慢，早期的操作系统就发明了多进程，即便在单核的 CPU 上我们也可以一边听着歌，一边写 Bug，这个就是多进程的功劳。

### 时间片

操作系统允许某个进程执行一小段时间，例如 50 毫秒，过了 50 毫秒操作系统就会重新选择一个进程来执行（我们称为“任务切换”），这个 50 毫秒称为“时间片”。

![](images/01_multi_task.png)

- 在一个时间片内，如果一个进程进行一个 IO 操作，例如读个文件，这个时候该进程可以把自己标记为“休眠状态”并出让 CPU 的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得 CPU 的使用权了。
- 进程在等待 IO 时之所以会释放 CPU 使用权，是为了让 CPU 在这段等待时间里可以做别的事情，这样一来 CPU 的使用率就上来了。
- 此外，如果这时有另外一个进程也读文件，读文件的操作就会排队，磁盘驱动在完成一个进程的读操作后，发现有排队的任务，就会立即启动下一个读操作，这样 IO 的使用率也上来了。

Unix 是率先解决这个问题的系统。

### 进程调度与线程调度

- 早期的操作系统基于进程来调度 CPU，不同进程间是不共享内存空间的，所以进程要做任务切换就要切换内存映射地址。
- 一个进程创建的所有线程，都是共享一个内存空间的，所以线程做任务切换成本就很低了。
- 现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。

### Java 并发程序——线程切换

- Java 并发程序都是基于多线程的，自然也会涉及到任务切换，这也是并发编程里诡异 Bug 的源头之一。
- 任务切换的时机大多数是在时间片结束的时候

### `+= 操作的指令` 与 原子性

高级语言里一条语句往往需要多条 CPU 指令完成，`count += 1`，至少需要三条 CPU 指令。

- 指令 1：首先，需要把变量 count 从内存加载到 CPU 的寄存器；
- 指令 2：之后，在寄存器中执行 +1 操作；
- 指令 3：最后，将结果写入内存（缓存机制导致可能写入的是 CPU 缓存而不是内存）。

操作系统做任务切换，可以发生在任何一条CPU 指令执行完，**是 CPU 指令，而不是高级语言里的一条语句**。这就无法保证 `count += 1` 的原子性：

![](images/01_atomic_operation.png)

原子性：**我们把一个或者多个操作在 CPU 执行的过程中不被中断的特性称为原子性**。CPU 能保证的原子操作是 CPU 指令级别的，而不是高级语言的操作符，这是违背我们直觉的地方。因此，很多时候我们需要在高级语言层面保证操作的原子性。

---
## 4 源头之三：编译优化带来的有序性问题

有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序（这叫做指令重排）。

例如程序中：`“a=6；b=7；”`编译器优化后可能变成`“b=7；a=6；”`在这个例子中，编译器调整了语句的顺序，但是不影响程序的最终结果。不过有时候编译器及解释器的优化可能导致意想不到的 Bug。

>注意：在单线程环境下，指令重排不会导致程序执行结果与编程逻辑不一致的情况，但是在多线程环境下，就会带来诡异的问题。

### Double-Check 式单例实现

在 Java 领域一个经典的案例就是利用双重检查创建单例对象：

```java
public class Singleton {
  static Singleton instance;
  static Singleton getInstance(){
    if (instance == null) {
      synchronized(Singleton.class) {
        if (instance == null)
          instance = new Singleton();
        }
    }
    return instance;
  }
}
```

这个 getInstance() 方法不完美。问题出在 new 操作上，我们以为的 new 操作应该是：

1. 分配一块内存 M；
2. 在内存 M 上初始化 Singleton 对象；
3. 然后 M 的地址赋值给 instance 变量。

但是实际上优化后的执行路径却是这样的：

1. 分配一块内存 M；
2. 然后 M 的地址赋值给 instance 变量。
3. 在内存 M 上初始化 Singleton 对象；

优化后会导致什么问题呢？我们假设线程 A 先执行 getInstance() 方法，当执行完指令 2 时恰好发生了线程切换，切换到了线程 B 上；如果此时线程 B 也执行 getInstance() 方法，那么线程 B 在执行第一个判断时会发现 instance != null ，所以直接返回 instance，而此时的 instance 是没有初始化过的，如果我们这个时候访问 instance 的成员变量就可能触发空指针异常。

![](images/01_double_check.png)

---
## 5 总结

要写好并发程序，首先要知道并发程序的问题在哪里，只有确定了“靶子”，才有可能把问题解决，毕竟所有的解决方案都是针对问题的。

- 并发程序经常出现的诡异问题看上去非常无厘头，但是深究的话，无外乎就是直觉欺骗了我们。只要我们能够深刻理解可见性、原子性、有序性在并发场景下的原理，很多并发 Bug 都是可以理解、可以诊断的。
- 缓存导致的可见性问题，线程切换带来的原子性问题，编译优化带来的有序性问题，其实缓存、线程、编译优化的目的和我们写并发程序的目的是相同的，都是提高程序性能。但是技术在解决一个问题的同时，必然会带来另外一个问题，所以在采用一项技术的同时，一定要清楚它带来的问题是什么，以及如何规避。

---
## 6 思考：在 32 位的机器上对 long 型变量进行加减操作存在并发隐患，到底是不是这样呢？

long 类型 64位，所以在32位的机器上，对 long 类型的数据操作通常需要多条指令组合出来，无法保证原子性，所以并发的时候会出问题。